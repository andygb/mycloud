<?xml version="1.0" encoding="UTF-8"?>
	<configuration debug="true" scan="true" scanPeriod="5 minutes">
		
		<!-- property 标签定义一些可在 当前 xml 中使用的变量 -->

		<!-- your application name -->
		<property name="MODULE" value="tradeService" />

		<property scope="system" name="nodeId" value="firstNode" />
		
		<!-- 日志文件存放地址 根地址 -->
		<property name="BASE_PATH" value="/opt/log/${MODULE}" />

		<!-- -->
		<!-- 定义不同级别类型的日志的存放地址 ， 不过info日志中包含了error, 单独列出error 是为了在更少的日志中快速查看 error级别的日志 -->
		<property name="INFO_FILE" value="${BASE_PATH}/info" />
		<property name="ERROR_FILE" value="${BASE_PATH}/error" />


		<!-- LOG_PATTERN 定义日志格式 -->
		<!-- uuid 需要自己加入到 MDC 中去， MDC是logback提供的一种在线程中存放日志相关记录的map对象。
		<property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} %X{remoteAddr} %X{hostname} [%thread] %-5level %logger{50} %X{uuid} - %msg%n" />
		-->
		<property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} %X{remoteAddr} %X{hostname} [%thread] %-5level %logger{50} %X{uuid} - %msg%n" />
		<!-- 定义日志的字符集 -->
		<property name="CHARSET" value="utf8" />
		
		<!-- 输出文件日志时使用 单个文件最大大小 -->		
		<property name="MAX_FILE_SIZE" value="50MB" />
		<!-- 输出文件日志时使用 单个文件最大大小 -->		
		<property name="MAX_HISTORY" value="60" />
		<!-- 输出文件日志时使用 单个文件最大大小 -->		
		<property name="TOTAL_SIZE_CAP" value="20GB" />
		<!-- 输出文件日志时使用 单个文件最大大小 -->		
		<property name="ROLL_FILE_PATTERN" value="%d{yyyy-MM-dd}-%i.log.gz" />


		<!-- console appender-->
		<appender name="console" class="ch.qos.logback.core.ConsoleAppender">
			<encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
				<pattern>${LOG_PATTERN}</pattern>
				<charset>${CHARSET}</charset>
			</encoder>
		</appender>
		
		
		<!-- 基于时间的滚动(归档)策略配置的 文件日志追加器  -->
		<appender name="infoFile" class="ch.qos.logback.core.rolling.RollingFileAppender">
			<encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
				<pattern>${LOG_PATTERN}</pattern>
				<charset>${CHARSET}</charset>
			</encoder>
			<file>${INFO_FILE}.log</file>
			
			
			<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
				<fileNamePattern>${INFO_FILE}/${ROLL_FILE_PATTERN}</fileNamePattern>
				<timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">  
	        		<maxFileSize>${MAX_FILE_SIZE}</maxFileSize>  
	      		</timeBasedFileNamingAndTriggeringPolicy>
			</rollingPolicy>
		</appender>
		
		<!-- error log appender-->
		<appender name="errorFile" class="ch.qos.logback.core.rolling.RollingFileAppender">
			<encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
				<pattern>${LOG_PATTERN}</pattern>
				<charset>${CHARSET}</charset>
			</encoder>
			<file>${ERROR_FILE}.log</file>
			<filter class="ch.qos.logback.classic.filter.ThresholdFilter">
		      <level>ERROR</level>
		    </filter>
			<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
				<fileNamePattern>${ERROR_FILE}/${ROLL_FILE_PATTERN}</fileNamePattern>
				<timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">  
	        		<maxFileSize>${MAX_FILE_SIZE}</maxFileSize>  
	      		</timeBasedFileNamingAndTriggeringPolicy>
			</rollingPolicy>
		</appender>
		
		
		<!-- root标签 特指 root名称的Logger 级根记录器 level属性表示：该记录器 允许打印的日志级别 
		  				   根记录器的级别默认是debug 级别，如果一个记录器logger没有设置 levele 会继承父级记录器的 level; 
		  				   
				遇到的问题：如果父级logger设置的 日志级别 比 子级logger的日志级别低， 那么使用子级logger 能打印出符合 父级日志级别的 日志；
				
				所以，一般要求，父级日志级别 大于等于 子级日志级别
						  				   
		  				   
		  				   -->
		<root level="DEBUG">
			<appender-ref ref="console" />
			<appender-ref ref="infoFile" />
			<appender-ref ref="errorFile" />
		</root>
		
		<!-- 设置名称为 com.juqitech 的 记录器， 
		  additivity 属性表示是否将 日志传递到父级记录器，让父级记录器继续打印，
		  一般没必要，因为如果当前这条日志的级别 父级记录器也允许打印，很出现多条同一日志； 
		  
		  
		  此处为何定义多个 logger标签， 为了控制不同名称的logger的日志打印级别，以及输出目的地；
		  
		  -->
		
		<logger level="DEBUG" name="org.springframework.boot" additivity="false">
			<appender-ref ref="infoFile" />
			<appender-ref ref="errorFile" />
			<appender-ref ref="console" />
		</logger>
	
		<logger level="DEBUG" name="org.springframework.web" additivity="false">
			<appender-ref ref="infoFile" />
			<appender-ref ref="errorFile" />
			<appender-ref ref="console" />
		</logger>
		
		<logger level="DEBUG" name="org.springframework.cloud" additivity="false">
			<appender-ref ref="infoFile" />
			<appender-ref ref="errorFile" />
			<appender-ref ref="console" />
		</logger>
		
		<logger level="INFO" name="com.netflix" additivity="false">
			<appender-ref ref="infoFile" />
			<appender-ref ref="errorFile" />
			<appender-ref ref="console" />
		</logger>

		<logger level="DEBUG" name="com.rick" additivity="false">
			<appender-ref ref="infoFile" />
			<appender-ref ref="errorFile" />
			<appender-ref ref="console" />
		</logger>

	<logger level="DEBUG" name="okhttp3" additivity="false">
		<appender-ref ref="infoFile" />
		<appender-ref ref="errorFile" />
		<appender-ref ref="console" />
	</logger>


	<logger level="DEBUG" name="feign.okhttp" additivity="false">
		<appender-ref ref="infoFile" />
		<appender-ref ref="errorFile" />
		<appender-ref ref="console" />
	</logger>

	<!-- Logger 日志记录器 ，一般代码中都会定义 一个logger 
			eg.  
			
				private final static Logger logger1 = LoggerFactory.getLogger("com");
				
				private final static Logger logger2 = LoggerFactory.getLogger("com.autumn");
				private final static Logger logger3 = LoggerFactory.getLogger(App.class); //App全类名：com.autumn.App
				
				private final static Logger logger4 = LoggerFactory.getLogger("com.spring");
				private final static Logger logger5 = LoggerFactory.getLogger("com.spring.");
					
					以上两种方式都可以获得一个Logger记录器，而括号中的App.class最终会转化为字符串 “com.autumn.App”，即为logger的名称，
					同一个名称的Logger对象只会有一个。
					同时logger对象是有父子级关系的，比如名称为"com.autumn"的logger对象是“com.autumn.App”名称的logger对象的父级;
					此外 所有logger对象的祖先是名为："root"的logger对象；
					
					所以： 
							logger3  -> logger2  -> logger1  -> root
							logger5  -> logger4  -> logger1  -> root
			
		 -->

		<!-- appender 即：追加器，logger 称为记录器，logger只是在内存中记录了一条日志，而日志具体要输出到哪里，就由追加器来决定 -->
		<!-- 常用的 追加器， 
		
		 ch.qos.logback.core.ConsoleAppender ：控制台追加器(控制台打印器)，即将日志 打印到 控制台，一般开发阶段用，配合IDE使用，方便开发者及时排查日志
		 
		 ch.qos.logback.core.FileAppender : 文件日志追加器，即将日志，输出到 文件中，生产环境使用，方便事后查看日志；
		 
		ch.qos.logback.core.rolling.RollingFileAppender ： 滚动文件日志追加器，因为日志是持续产生的，如果一直将日志写在同一个文件中，文件太大比好查看。
																											而滚动文件日志就是 按时间或者大小， 以及在按时间的条件下再按大小，将日志输出到不同文件中去，
																											
																											有三种不同的策略
																											1. 
																											2.
																											3.
																								
		
		
		 -->
		 
		 
</configuration>

